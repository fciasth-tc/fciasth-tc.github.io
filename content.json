{"pages":[{"title":"About","text":"Nickname: fciasth Email: 2290262044@qq.com Github: @tcxiaotudou","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"5款好用的开源Docker工具","text":"最近，开发者谢哈尔·古拉蒂（Shekhar Gulati）收集了一些他在日常工作中使用的又有趣又实用的 Docker 工具，他称这些工具提升了自己的工作效率，减少了原本需要手工完成的工作。以下就是古拉蒂推荐的五款开源 Docker 工具，以及他选择它们的原因。 Watchtower：自动更新 Docker 容器 Watchtower 监视运行容器以及这些容器最初启动时的镜像状态。当 Watchtower 检测到一个镜像已经有变动时，它会使用新镜像自动重新启动相应的容器。我想在我的本地开发环境中尝试最新的构建镜像，所以使用了它。 Watchtower 本身被打包为 Docker 镜像，因此可以像运行任何其它容器一样运行它。要运行 Watchtower，你需要执行以下命令： 1$ docker run -d --name watchtower --rm -v /var/run/docker.sock:/var/run/docker.sock v2tec/watchtower --interval 30 在上面的命令中，我们使用一个挂载文件（/var/run/docker.sock）启动了 Watchtower 容器。这么做是有必要的，为的是使 Watchtower 可以与 Docker 守护 API 进行交互。我们将 30 秒传递给间隔选项 interval，此选项定义了 Watchtower 的轮询间隔。Watchtower 支持更多的选项，你可以根据文档中的描述来使用它们。 Docker-gc：容器和镜像的垃圾回收 Docker-gc 工具通过删除不需要的容器和镜像来帮你清理 Docker 主机。它会删除存在超过一个小时的所有容器。此外，它还删除不属于任何留置容器的镜像。 你可以将 Docker-gc 作为脚本和容器来使用。若要使用 Docker-gc 来查找所有可以删除的容器和镜像，命令如下： 1$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -e DRY RUN=1 spotify/docker-gc 上述命令中，我们加载了 docker.sock 文件，以便 Docker-gc 能够与 Docker API 交互。我们传递了一个环境变量 DRY_RUN=1 来查找将被删除的容器和镜像。需要注意的是，如果不提供该参数，Docker-gc 会删除所有容器和镜像，所以最好事先确认 Docker-gc 要删除的内容。上述命令的输出如下所示： 12345678910[2017-04-28T06:27:24] [INFO] : The following container would have been removed 0c1b3b0972bb792bee508 60c35a4 bc08ba32b527d53eab173d12a15c28deb931/vibrant_ yonath[2017-04-28T06:27:24] [INFO] : The following container would have been removed 2a72d41e4b25e2782f7844e188643e395650a9ecca660e7a0dc2b7989e5acc28 /friendlyhello_ web[2017-04-28T06:27:24] [INFO] : The following image would have been removed sha256:00f017a8c2a6e1 fe2f fd05c281 f27d069d2a99323a8cd514dd35f228ba26d2ff[busybox: latest][2017-04-28T06:27:24] [ INFO] : The following image would have been removed sha256 :4a323b466a5ac4ce6524 8dd970b538922c54e535700cafe9448b52a3094483ea[hello-world:latest][2017-04-28T06:27:24] [INFO] : The following image would have been removed sha256:4a323b4 66a5ac4ce65248dd970b538922c54e535700cafe9448b52a3094483ea[python:2.7-slim] 如果你认同 Docker-gc 清理方案， 可以不使用 DRY_RUN 再次运行 Docker-gc 执行清空操作。 1$ docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc Docker-slim：面向容器的神奇“减肥药” 如果你担心你的 Docker 镜像的大小，Docker-slim 可以帮你排忧解难。 该工具使用静态和动态分析方法来为你臃肿的镜像瘦身。要使用 Docker-slim，可以从 GitHub 下载 Linux 或者 Mac 的二进制安装包。成功下载之后，将它加入到你的系统变量 PATH 中。 Rocker：突破 Dockerfile 的限制 大多数使用 Docker 的开发人员都使用 Dockerfile 来构建镜像。Dockerfile 是一种声明式的方法，用于定义用户可以在命令行上调用的所有命令，从而组装镜像。 Rocker 为 Dockerfile 指令集增加了新的指令。据了解，Rocker 的创建者 Grammarly 正是为了解决他们遇到的 Dockerfile 格式的问题，才创建了 Rocker。要使用 Rocker，首先必须在你的机器上安装。对 Mac 用户来说，就是简单地运行几条 brew 命令： 12$ brew tap grammarly/tap$ brew install grammarly/tap/rocker 一旦完成安装，你就可以通过传递 Rockerfile 使用 Rocker 来构建镜像了： 123456789FROM python:2.7-slimWORKDIR /appADD . /appRUN pip install -r requirements. txtEXPOSE 80ENV NAME WorldCMD [&quot;python&quot;,&quot;app.Py&quot;]TAG shekhargulati/ friendlyhello:{{ .VERSION }}PUSH shekhargulati/friendlyhello:{{ .VERSION }} 若要构建一个镜像并将其推送到 Docker Hub，你可以运行以下命令： 1$ rocker d build --push -var VERSION-1.0 Rocker 有一组很好的特性，要了解更多信息，请参考它的文档。 ctop：容器的类顶层接口Ctop 是我最近开始使用的一个工具，它能够提供多个容器的实时指标视图。如果你是一个 Mac 用户，可以使用 brew 安装，如下所示： 1$ brew install ctop 一旦完成安装，就可以开始使用 ctop 了。你只需要配置 DOCKER_HOST 环境变量。你可以运行 ctop 命令，查看所有容器的状态。若只想查看正在运行的容器，可以使用 ctop -a 命令。 Ctop 是一个简单的工具，对于了解在你的主机上运行的容器很有帮助。你可以在 ctop 文档中了解更多相关信息。以上就是古拉蒂发现的 5 款实用 Docker 工具。 原文链接：5 Docker Utilities You Should Know","link":"/2019/12/25/5%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E5%BC%80%E6%BA%90Docker%E5%B7%A5%E5%85%B7/"},{"title":"ElasticSearch配置外网访问，开放9200端口","text":"前言最近在学习springboot整合elasticsearch，在腾讯云的服务器上用docker装上es后，发现elasticsearch默认不开放外网访问。所以折腾了一下。记录一下配置流程。 配置流程1. 进入elasticsearch主目录下 1vim config/elasticsearch.yml 2. 添加下面内容 12network.host: 0.0.0.0http.port: 9200 注：前面没有#注释，还有就是顶头加一个空格，冒号后也要加空格。 ==&gt; 空格 network.host:空格 0.0.0.0","link":"/2018/05/27/ElasticSearch%E9%85%8D%E7%BD%AE%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%BC%80%E6%94%BE9200%E7%AB%AF%E5%8F%A3/"},{"title":"Git在错误的分支上进行开发，处理方式","text":"最近在开发项目的一个小需求的时候，发生了一件尴尬的事情。那就是当我把新功能开发完成的时候，忽然发现自己开发使用的分支是错误的分支。不过我记得之前学习git的时候有一个git stash的命令可以把当前没有提交的内容存档起来，然后可以在切换分支之后把当前的存档应用到目标分支。不过因为平时不怎么使用这个命令，所以有点生疏了，需要再次去看看文档。 花了十几分钟，把git stash相关的命令又再次温习了一下，接着就顺利地把这个问题给解决掉。因为平时的开发也都是遵循相关的git流程，一般不会出现什么错误，而且平时使用的git命令也都是一些常用的。这次出现这个问题有一部分原因是因为这个项目不是一个长期维护的项目，当开发新功能的时候，一打开项目，就以为还在自己的开发分支。也没及时检查一下开发的分支是否正确。更深层次的原因还是因为git掌握得不够好。也正好借这个机会，把相关的命令再次好好复习一下，也挺好的。 其实当你在错误的分支开发了新功能之后，这里会有三种情况： 新功能还没有在本地进行commit（提交），也就是我这次遇到的情况 新功能已经在本地提交了，但是还没有push到远程仓库 新功能已经在本地提交了，且push到了远程仓库 虽然我遇到的是第一种情况，那么当我解决这个问题之后，我很自然的就会想：如果遇到了另外两种情况我该怎么处理呢？这篇文章就跟大家一起探讨一下针对上述三种情况下，如果你在错误的分支开发了新功能，我们应该怎么做。 新功能还没有在本地进行commit（提交）在这种情况下我们可以在当前分支下使用： 1git stash 这个命令表示把我们当前修改的内容暂存起来，然后我们的工作区就恢复到在没有开发新功能之前的样子。 这个时候我们需要切换到正确的工作分支，然后运行命令： 1git stash apply 这个命令表示把我们之前暂存的内容，应用到当前分支。这样我们就相当于把修改的内容从一个分支移动到了另一个分支，是不是很简单呢。 上面那两个命令也是我解决这个问题中使用的命令。我觉得不能满足于只解决这个问题，我需要详细的了解一下有关git stash的命令，接下来的内容是关于git stash的一些深入的内容，我们不仅要知其然，还要知其所以然。 首先我们需要知道使用git stash命令会把我们工作区和暂存区的修改保存下来，然后将这些修改的内容从当前的文件中移出并保存在存档库里面。所以我们就回到了之前没有修改过内容的干净的工作区。 git stash在没有添加任何参数的时候相当于git stash push命令，我们使用git stash创建一个当前修改的快照的时候，命令运行完会给出如下的信息： 1Saved working directory and index state WIP on &lt;branchname&gt;: &lt;hash&gt; &lt;commit message&gt; 其中branchname是你当前所在分支的名字，hash是当前分支最近一次提交的hash值，commit message就是你最近的一次提交的时候添加的提交信息。 对于当前只想存储一个快照的情况下使用git stash是比较方便直观的，如果你在当前分支想存储多个快照，那么最好给每一个快照添加一些解释信息，以便使用的时候能够知道每一个快照都是干嘛的。 我们可以使用git stash push -m message来给每一个快照添加详细的说明信息，比如： 1git stash push -m “add feature 1” 在这个命令行运行完成之后，在终端上会显示如下的信息： 1Saved working directory and index state On &lt;branchname&gt;: add feature 1 根据终端显示的信息，我们可以知道当前这个快照是在那个分支产生的，并且有了add feature 1这个详细的描述，等到以后使用的时候会更加的清楚一点。 当我们有了很多快照的时候，我们可能想看一下当前的快照列表。这个时候我们可以使用git stash list来看一下当前的快照列表。在终端运行git stash list后，如果你在之前添加了一些快照的话，会显示如下的一些信息： 12345stash@{0}: On &lt;branchname&gt;: add feature 1stash@{1}: On &lt;branchname&gt;: add feature 0stash@{2}: On &lt;branchname&gt;: &lt;message&gt;stash@{3}: WIP on &lt;branchname&gt;: 47e52ae &lt;commit message&gt;stash@{4}: On &lt;branchname&gt;: &lt;message&gt; 从上面的信息中我们可以知道最新的快照是排在最上面的，存储快照的是一个栈，所以最新添加的快照是放在最上面的。 **如果我们想查看最近一次快照跟生成快照当时已提交的文件之间的变化情况的话，可以使用命令git stash show。这个命令默认展示的是文件的差别统计。如果想展示具体改动的内容的话，可以使用git stash show -p**。 因为我们有不止一个快照，所以我们还想要看之前的快照跟产生这个快照当时已提交的版本之间的差异的话，我们可以在上面的命令后面添加快照的索引，比如如果你想看上面add feature 0这个快照的文件变动的话，可以使用下面的命令： 12git stash show stash@{1} # 简略的信息git stash show -p stash@{1} # 详细的内容更改 接下来就到了应用（恢复）快照的时候了，如果这时候你想把某个快照的内容应用于当前的分支的话，只需要运行命令： 12git stash apply # 将最新的快照内容应用于当前分支git stash apply stash@{n} # n表示具体的快照索引 这样就可以把之前保留的快照内容应用到当前的版本中了，在应用快照的过程中可能会产生冲突，这时候需要手动把冲突的内容处理一下，然后再次提交就可以了。 git stash apply可以添加--index参数，这个参数的作用是在应用快照的时候，会把之前已经添加到暂存区（索引区）的更改依旧保存在暂存区，如果不添加这个参数的话，所有的变更都会变成在工作区的变更（也就是没有保存在索引区的状态）。 我们可以测试一下，对一个文件进行更改，然后把更改添加（使用git add）到暂存区，然后再次添加一个更改，这次不添加到暂存区。我们运行git status命令会看到如下的内容： 1234567891011On branch devChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: 20200830/index.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: 20200830/README.md 当我们运行git stash命令，然后运行git stash apply命令之后，会看到如下信息： 123456789On branch devChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: 20200830/README.md modified: 20200830/index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 所以当不使用--index参数的时候，不会保存之前在暂存区的状态。 关于git stash还有一些其它的命令，比如： git stash drop：丢弃一个快照 git stash pop：应用最新的快照到当前分支，如果应用成功的话就把这个快照从存储快照的栈中移除 git stash clear：清除所有的快照 关于git stash一些常用的命令和操作上面已经讲解的差不多啦，如果大家想继续了解更多的话，可以参考git-stash。 上面的内容主要是在我们新开发的功能还没有提交的情况下所做的一些处理，当我们开发的新功能已经在本地提交了的情况下，我们该如何处理呢？接下来我们就来探讨一下这个问题。 新功能已经在本地提交了，但是还没有push到远程仓库如果新开发的功能已经在本地提交了，但是我们开发的这个分支是一个错误的分支。这个时候根据情况的不同，可以有两种处理的方式。 新的功能需要添加在一个新的分支首先我们需要知道在我们添加新功能之前，当前分支处于哪一个提交。可以运行命令： 1git log --oneline 查看当前分支的提交，可以看到有以下内容的输出： 12345085095f (HEAD -&gt; master) update 547e52ae update 314fefac update 2fd01444 add README.md3c76ad1 init 找到我们添加新功能时，当前分支所处的提交。假如是fd01444，那么我们接下来要做的操作就是将HEAD指针指向fd01444，也就是把我们当前分支已提交的内容重置到我们开发新功能之前的样子。我们需要运行下面的命令： 1git reset fd01444 # fd01444是某次提交的hash值 如果没有指明重置的模式的话，默认会使用--mixed模式，这样的话我们在fd01444这次提交之后的所有提交都会被重置为没有提交的状态。接下来我们需要把这些新开发的功能迁移到一个新的分支。这时候我们可以使用下面的命令进行操作： 1git checkout -b &lt;newbranch&gt; 这样我们就创建了一个新的分支，并且把新添加的功能也都迁移了过去，接下来就是常规的添加和提交操作了。 新功能需要添加在另一个分支上如果我们需要把当前添加的新功能迁移到另一个已经存在的分支，那么我们需要做的前几个步骤跟上面的操作是一样的： 12git log --oneline # 查找新功能开发之前的提交git reset &lt;commit hash&gt; # 将当前分支重置到新功能开发之前的提交 接下来我们现在的状态就回到了新功能还没有提交的状态，那么就可以继续使用git stash相关的命令去操作了。 我们还有另外一个方法也能够将已提交到当前分支的功能添加到另一个分支上，那就是使用git cherry-pick命令。首先我们还是先用git log --oneline查找当前已提交的功能的hash值，然后切换到目标分支，运行命令： 1git cherry-pick &lt;commit hash&gt; 这样就把我们在另一个分支开发的功能，添加到我们想要的分支了。如果有冲突的话，需要手动处理一下冲突。然后我们回到最初的分支，再次运行git reset &lt;commit hash&gt;命令，把已提交的内容进行重置，然后运行命令： 1git checkout -- . 把当前分支没有添加到暂存区的内容都清除掉，这样也可以达到我们上面所说的，把新功能添加到另一个分支的目的。 新功能已经在本地提交了，且push到了远程仓库第三种情况就是，我们已经把新开发的功能push到远程的仓库了，但是我们忽然发现新功能不应该在这个分支开发，我们这个时候应该怎么办呢？ 首先我们应该保持当前的工作区是没有修改的，是一个干净的状态。不然使用撤销命令的时候会提示你需要把当前的文件内容变更先提交或者生成快照。当我们的工作区的状态是干净的时候，我们就可以进行撤销操作了。 首先需要知道我们应该撤销那一次提交的状态。使用git log --oneline查看要撤销的提交的索引，然后运行下面的命令： 1git revert &lt;commit&gt; 这个时候命令运行的终端会进入编辑器模式，让你填写提交的信息。当然你也可以使用参数--no-edit这样就不会在进行撤销操作的时候打开编辑模式了。 如果需要撤销的提交比较多的话，我们可以使用..表示一个提交记录的范围。比如c1..c2就表示c2的可达提交，且排除c1的可达提交。所谓可达的提交指的是：提交本身及其祖先链中提交的集合。 我们可以举个例子： 1... a - b - c - d - HEAD 如果上面表示的是某个分支的提交记录，那么对于b..d表示的就是c d这两个提交，对于a..d表示的就是b c d这三个提交。如果大家想了解更多相关的内容，可以在git-rev-list这里深入的学习一下。 所以我们如果想快速的撤销一段范围的提交的话，可以运行类似下面这样的命令： 1git revert 54dc134..a72d612 --no-edit 上述命令的54dc134就表示c1，a72d612就表示c2，--no-edit表明我们在运行撤销操作的时候不打开编辑模式。 我们如果需要对远程的分支进行撤销的话，首先考虑的就是使用git revert命令，因为git revert命令不会修改历史的提交记录，只是在原来的提交基础上添加新的提交，所以不会造成代码的丢失。在多人合作的情况下使用git revert命令撤销push到远程的操作还是很有必要的。","link":"/2020/05/27/Git%E5%9C%A8%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8A%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91%EF%BC%8C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"},{"title":"Golang并发的次优选择：sync包","text":"我们都知道Golang并发优选channel，但channel不是万能的，Golang为我们提供了另一种选择：sync。通过这篇文章，你会了解sync包最基础、最常用的方法，至于sync和channel之争留给下一篇文章。 sync包提供了基础的异步操作方法，比如互斥锁（Mutex）、单次执行（Once）和等待组（WaitGroup），这些异步操作主要是为低级库提供，上层的异步/并发操作最好选用通道和通信。 sync包提供了： Mutex：互斥锁 RWMutex：读写锁 WaitGroup：等待组 Once：单次执行 Cond：信号量 Pool：临时对象池 Map：自带锁的map 这篇文章是sync包的入门文章，所以只介绍常用的结构和方法：Mutex、RWMutex、WaitGroup、Once，而Cond、Pool和Map留给大家自行探索，或有需求再介绍。 互斥锁常做并发工作的朋友对互斥锁应该不陌生，Golang里互斥锁需要确保的是某段时间内，不能有多个协程同时访问一段代码（临界区）。 互斥锁被称为Mutex，它有2个函数，Lock()和Unlock()分别是获取锁和释放锁，如下： 123type Mutexfunc (m *Mutex) Lock(){}func (m *Mutex) Unlock(){} Mutex的初始值为未锁的状态，并且Mutex通常作为结构体的匿名成员存在。 经过了上面这么“官方”的介绍，举个例子：你在工商银行有100元存款，这张卡绑定了支付宝和微信，在中午12点你用支付宝支付外卖30元，你在微信发红包，抢到10块。银行需要按顺序执行上面两件事，先减30再加10或者先加10再减30，结果都是80，但如果同时执行，结果可能是，只减了30或者只加了10，即你有70元或者你有110元。前一个结果是你赔了，后一个结果是银行赔了，银行可不希望把这种事算错。 看看实际使用吧：创建一个银行，银行里存每个账户的钱，存储查询都加了锁操作，这样银行就不会算错账了。银行的定义： 1234567891011type Bank struct { sync.Mutex saving map[string]int // 每账户的存款金额}func NewBank() *Bank { b := &amp;Bank{ saving: make(map[string]int), } return b} 银行的存取钱： 1234567891011121314151617181920212223242526272829303132333435363738// Deposit 存款func (b *Bank) Deposit(name string, amount int) { b.Lock() defer b.Unlock() if _, ok := b.saving[name]; !ok { b.saving[name] = 0 } b.saving[name] += amount}// Withdraw 取款，返回实际取到的金额func (b *Bank) Withdraw(name string, amount int) int { b.Lock() defer b.Unlock() if _, ok := b.saving[name]; !ok { return 0 } if b.saving[name] &lt; amount { amount = b.saving[name] } b.saving[name] -= amount return amount}// Query 查询余额func (b *Bank) Query(name string) int { b.Lock() defer b.Unlock() if _, ok := b.saving[name]; !ok { return 0 } return b.saving[name]} 模拟操作：小米支付宝存了100，并且同时花了20。 1234567891011func main() { b := NewBank() go b.Deposit(&quot;xiaoming&quot;, 100) go b.Withdraw(&quot;xiaoming&quot;, 20) go b.Deposit(&quot;xiaogang&quot;, 2000) time.Sleep(time.Second) fmt.Printf(&quot;xiaoming has: %d\\n&quot;, b.Query(&quot;xiaoming&quot;)) fmt.Printf(&quot;xiaogang has: %d\\n&quot;, b.Query(&quot;xiaogang&quot;))}结果：先存后花。 1234➜ sync_pkg git:(master) ✗ go run mutex.goxiaoming has: 80xiaogang has: 2000也可能是：先花后存，因为先花20，因为小明没钱，所以没花出去。 123➜ sync_pkg git:(master) ✗ go run mutex.goxiaoming has: 100xiaogang has: 2000 这个例子只是介绍了mutex的基本使用，如果你想多研究下mutex，Github中还提供了没有锁的例子，运行多次总能碰到错误： fatal error: concurrent map writes这是由于并发访问map造成的。 读写锁读写锁是互斥锁的特殊变种，如果是计算机基本知识扎实的朋友会知道，读写锁来自于读者和写者的问题，这个问题就不介绍了，介绍下我们的重点：读写锁要达到的效果是同一时间可以允许多个协程读数据，但只能有且只有1个协程写数据。 也就是说，读和写是互斥的，写和写也是互斥的，但读和读并不互斥。具体讲，当有至少1个协程读时，如果需要进行写，就必须等待所有已经在读的协程结束读操作，写操作的协程才获得锁进行写数据。当写数据的协程已经在进行时，有其他协程需要进行读或者写，就必须等待已经在写的协程结束写操作。 读写锁是RWMutex，它有5个函数，它需要为读操作和写操作分别提供锁操作，这样就4个了： Lock()和Unlock()是给写操作用的。 RLock()和RUnlock()是给读操作用的。 RLocker()能获取读锁，然后传递给其他协程使用。使用较少。 123456type RWMutexfunc (rw *RWMutex) Lock(){}func (rw *RWMutex) RLock(){}func (rw *RWMutex) RLocker() Locker{}func (rw *RWMutex) RUnlock(){}func (rw *RWMutex) Unlock(){} 上面的银行实现不合理：大家都是拿手机APP查余额，可以同时几个人一起查呀，这根本不影响，银行的锁可以换成读写锁。存、取钱是写操作，查询金额是读操作，代码修改如下，其他不变： 1234567891011121314151617181920212223242526272829303132333435type Bank struct { sync.RWMutex saving map[string]int // 每账户的存款金额}// Query 查询余额func (b *Bank) Query(name string) int { b.RLock() defer b.RUnlock() if _, ok := b.saving[name]; !ok { return 0 } return b.saving[name]}func main() { b := NewBank() go b.Deposit(&quot;xiaoming&quot;, 100) go b.Withdraw(&quot;xiaoming&quot;, 20) go b.Deposit(&quot;xiaogang&quot;, 2000) time.Sleep(time.Second) print := func(name string) { fmt.Printf(&quot;%s has: %d\\n&quot;, name, b.Query(name)) } nameList := []string{&quot;xiaoming&quot;, &quot;xiaogang&quot;, &quot;xiaohong&quot;, &quot;xiaozhang&quot;} for _, name := range nameList { go print(name) } time.Sleep(time.Second)} 结果，可能不一样，因为协程都是并发执行的，执行顺序不固定： 12345➜ sync_pkg git:(master) ✗ go run rwmutex.goxiaohong has: 0xiaozhang has: 0xiaogang has: 2000xiaoming has: 100 等待组互斥锁和读写锁大多数人可能比较熟悉，而对等待组（WaitGroup）可能就不那么熟悉，甚至有点陌生，所以先来介绍下等待组在现实中的例子。 你们团队有5个人，你作为队长要带领大家打开藏有宝藏的箱子，但这个箱子需要4把钥匙才能同时打开，你把寻找4把钥匙的任务，分配给4个队员，让他们分别去寻找，而你则守着宝箱，在这等待，等他们都找到回来后，一起插进钥匙打开宝箱。 这其中有个很重要的过程叫等待：等待一些工作完成后，再进行下一步的工作。如果使用Golang实现，就得使用等待组。 等待组是WaitGroup，它有3个函数: Add()：在被等待的协程启动前加1，代表要等待1个协程。 Done()：被等待的协程执行Done，代表该协程已经完成任务，通知等待协程。 ```goWait() 12345678: 等待其他协程的协程，使用Wait进行等待。```gotype WaitGroupfunc (wg *WaitGroup) Add(delta int){}func (wg *WaitGroup) Done(){}func (wg *WaitGroup) Wait(){} 来，一起看下怎么用WaitGroup实现上面的问题。 队长先创建一个WaitGroup对象wg，每个队员都是1个协程， 队长让队员出发前，使用wg.Add()，队员出发寻找钥匙，队长使用wg.Wait()等待（阻塞）所有队员完成，某个队员完成时执行wg.Done()，等所有队员找到钥匙，wg.Wait()则返回，完成了等待的过程，接下来就是开箱。 结合之前的协程池的例子，修改成WG等待协程池协程退出，实例代码： 123456789101112131415func leader() { var wg sync.WaitGroup wg.Add(4) for i := 0; i &lt; 4; i++ { go follower(&amp;wg, i) } wg.Wait() fmt.Println(&quot;open the box together&quot;)}func follower(wg *sync.WaitGroup, id int) { fmt.Printf(&quot;follwer %d find key\\n&quot;, id) wg.Done()} 结果: 123456➜ sync_pkg git:(master) ✗ go run waitgroup.gofollwer 3 find keyfollwer 1 find keyfollwer 0 find keyfollwer 2 find keyopen the box together WaitGroup也常用在协程池的处理上，协程池等待所有协程退出： 123456789101112131415161718192021func workerPool(n int, jobCh &lt;-chan int, retCh chan&lt;- string) { var wg sync.WaitGroup wg.Add(n) for i := 0; i &lt; n; i++ { go worker(&amp;wg, i, jobCh, retCh) } wg.Wait() close(retCh)}func worker(wg *sync.WaitGroup, id int, jobCh &lt;-chan int, retCh chan&lt;- string) { cnt := 0 for job := range jobCh { cnt++ ret := fmt.Sprintf(&quot;worker %d processed job: %d, it's the %dth processed by me.&quot;, id, job, cnt) retCh &lt;- ret } wg.Done()} 单次执行在程序执行前，通常需要做一些初始化操作，但触发初始化操作的地方是有多处的，但是这个初始化又只能执行1次，怎么办呢？ 使用Once就能轻松解决，once对象是用来存放1个无入参无返回值的函数，once可以确保这个函数只被执行1次。 12type Oncefunc (o *Once) Do(f func()){} 直接把官方代码给大家搬过来看下，once在10个协程中调用，但once中的函数onceBody()只执行了1次： 1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;sync&quot;)func main() { var once sync.Once onceBody := func() { fmt.Println(&quot;Only once&quot;) } done := make(chan bool) for i := 0; i &lt; 10; i++ { go func() { once.Do(onceBody) done &lt;- true }() } for i := 0; i &lt; 10; i++ { &lt;-done }} 结果： 12➜ sync_pkg git:(master) ✗ go run once.goOnly once","link":"/2020/06/28/Golang%E5%B9%B6%E5%8F%91%E7%9A%84%E6%AC%A1%E4%BC%98%E9%80%89%E6%8B%A9%EF%BC%9Async%E5%8C%85/"},{"title":"Go语言struct methods该使用pointer或value传值?","text":"在 Go 语言如何区分 func (s *MyStruct) 及 func (s MyStruct)，底下我们先来看看简单的 Struct 例子 1234567891011121314151617package mainimport &quot;fmt&quot;type Cart struct { Name string Price int}func (c Cart) GetPrice() { fmt.Println(c.Price)}func main() { c := &amp;Cart{&quot;bage&quot;, 100} c.GetPrice()} 上面是个很简单的 Go struct 例子，假设我们需要动态更新 Price 值，可以新增 UpdatePrice method。线上执行范例 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type Cart struct { Name string Price int}func (c Cart) GetPrice() { fmt.Println(&quot;price:&quot;, c.Price)}func (c Cart) UpdatePrice(price int) { c.Price = price}func main() { c := &amp;Cart{&quot;bage&quot;, 100} c.GetPrice() c.UpdatePrice(200) c.GetPrice()} 上面可以看到输出的结果是 100，只用 value 传值是无法改 Struce 内成员。我们可以用另外方式绕过。线上执行范例 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;type Cart struct { Name string Price int}func (c Cart) GetPrice() { fmt.Println(&quot;price:&quot;, c.Price)}func (c Cart) UpdatePrice(price int) *Cart { c.Price = price return &amp;c}func main() { c := &amp;Cart{&quot;bage&quot;, 100} c.GetPrice() c = c.UpdatePrice(200) c.GetPrice()} 从上面范例可以发现，将 struct 回传，这样就可以正确拿到修改的值。但是这解法不是我们想要的。来试试看用 Pointer 方式 线上执行范例 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type Cart struct { Name string Price int}func (c Cart) GetPrice() { fmt.Println(&quot;price:&quot;, c.Price)}func (c Cart) UpdatePrice(price int) { fmt.Println(&quot;[value] Update Price to&quot;, price) c.Price = price}func (c *Cart) UpdatePricePointer(price int) { fmt.Println(&quot;[pointer] Update Price to&quot;, price) c.Price = price}func main() { c := &amp;Cart{&quot;bage&quot;, 100} c.GetPrice() c.UpdatePrice(200) fmt.Println(c) c.UpdatePricePointer(200) fmt.Println(c)} 只要使用 pointer 方式传值就可以正确将您需要改变的值写入，所以这边可以结论就是，如果只是要读值，可以使用 Value 或 Pointer 方式，但是要写入，则只能用 Pointer 方式。其实在 Go 语言官方有整理 FAQ，竟然之前都没发现，参考底下官方给的建议。 写入或读取如果您需要对 Struct 内的成员进行修改，那请务必使用 Pointer 传值，相反的，Go 会使用 Copy struct 方式来传入，但是用此方式你就拿不到修改后的资料。 效能假设 Struct 内部成员非常的多，请务必使用 Pointer 方式传入，这样省下的系统资源肯定比 Copy Value 的方式还来的多。 一致性在开发团队内，如果有人使用 Pointer 有人使用 Value 方式，这样写法不统一，造成维护效率非常低，所以官方建议，全部使用 Pointer 方式是最好的写法。","link":"/2019/09/11/Go%E8%AF%AD%E8%A8%80struct-methods%E8%AF%A5%E4%BD%BF%E7%94%A8pointer%E6%88%96value%E4%BC%A0%E5%80%BC/"},{"title":"Go语言搭配Docker Healthy Check检查","text":"在 Docker 1.12 版本后，提供了 HEALTHCHECK 指令，通过指定的一行命令来判断容器内的服务是否正常运作。在此之前大部分都是透过判断程式是否 Crash 来决定容器是否存活，但是这地方有点风险的是，假设服务并非 crash，而是没办法退出容器，造成无法接受新的请求，这就确保容器存活。现在呢我们可以透过在 Dockerfile 内指定 HEALTHCHECK 指令来确保服务是否正常。而用 Go 语言开发的 Web 服务该如何来实现呢？ 建立 /healthz 路由透过简单的路由 /healthz 直接回传 200 status code 即可 (使用 Gin 当例子)。 123func heartbeatHandler(c *gin.Context) { c.AbortWithStatus(http.StatusOK)} 透過瀏覽器 http://localhost:8080/healthz 可以得到空白網頁，但是打開 console 可以看到正確回傳值。 建立 ping 指令透过 net/http 套件可以快速写个验证接口的函式 1234567891011func pinger() error { resp, err := http.Get(&quot;http://localhost:8080/healthz&quot;) if err != nil { return err } defer resp.Body.Close() if resp.StatusCode != 200 { return fmt.Errorf(&quot;server returned non-200 status code&quot;) } return nil} 增加 HEALTHCHECK 指令在 Dockerfile 內增加底下內容: 12HEALTHCHECK --start-period=2s --interval=10s --timeout=5s \\CMD [&quot;/bin/gorush&quot;, &quot;--ping&quot;] –start-period: 容器启动后需要等待几秒，预设为 0 秒 –interval: 侦测间隔时间，预设为 30 秒 –timeout: 检查超时时间 重新编译容器，并且启动容器，会看到初始状态为 經過 10 秒後，就會執行指定的指令，就可以知道容器健康與否，最後狀態為 。 最后可以透过 docker inspect 指令来知道容器的状态列表 (JSON 格式) 1$ docker inspect --format '{{json .State.Health}}' gorush | jq 从上图可以知道每隔 10 秒 Docker 就会自动侦测一次。有了上述这些资料，就可以来写系统报警通知了。","link":"/2019/03/17/Go%E8%AF%AD%E8%A8%80%E6%90%AD%E9%85%8DDocker-Healthy-Check%E6%A3%80%E6%9F%A5/"},{"title":"ServerSocketChannel绑定端口的两种方式","text":"近期学习NIO的时候，发现ServerSocketChannel有两种绑定端口的方式： 1234567// 方式1InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(inetSocketAddress); SocketChannel scoketChannel = serverSocketChannel.accept(); 1234567// 方式2InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.bind(inetSocketAddress);SocketChannel socketChannel = serverSocketChannel.accept(); 两种方式唯一的区别在于ServerSocketChannel是否先获取了ServerSoket。 123// 方式1serverSocketChannel.socket() // 先获取ServerScoket .bind(inetSocketAddress); // 再调用ServerScoket的bind方法 123// 方式2// 直接调用ServerSocketChannel的实现类ServerSocketChannelImpl的bind方法serverSocketChannel.bind(inetSocketAddress); 通过追源码的方式可以看到： 12345678910111213141516171819202122232425262728293031// ServerScoket类的bind方法实现，JDK 1.4 引入// backlog = 50public void bind(SocketAddress endpoint, int backlog) throws IOException { if (isClosed()) throw new SocketException(&quot;Socket is closed&quot;); if (!oldImpl &amp;&amp; isBound()) throw new SocketException(&quot;Already bound&quot;); if (endpoint == null) endpoint = new InetSocketAddress(0); if (!(endpoint instanceof InetSocketAddress)) throw new IllegalArgumentException(&quot;Unsupported address type&quot;); InetSocketAddress epoint = (InetSocketAddress) endpoint; if (epoint.isUnresolved()) throw new SocketException(&quot;Unresolved address&quot;); if (backlog &lt; 1) backlog = 50; try { SecurityManager security = System.getSecurityManager(); if (security != null) security.checkListen(epoint.getPort()); getImpl().bind(epoint.getAddress(), epoint.getPort()); getImpl().listen(backlog); bound = true; } catch(SecurityException e) { bound = false; throw e; } catch(IOException e) { bound = false; throw e; } } 12345678910111213141516171819202122232425262728// ServerSocketChannelImpl类的bind方法实现，JDK 1.7 引入// var2 = 0public ServerSocketChannel bind(SocketAddress var1, int var2) throws IOException { Object var3 = this.lock; synchronized(this.lock) { if (!this.isOpen()) { throw new ClosedChannelException(); } else if (this.isBound()) { throw new AlreadyBoundException(); } else { InetSocketAddress var4 = var1 == null ? new InetSocketAddress(0) : Net.checkAddress(var1); SecurityManager var5 = System.getSecurityManager(); if (var5 != null) { var5.checkListen(var4.getPort()); } NetHooks.beforeTcpBind(this.fd, var4.getAddress(), var4.getPort()); Net.bind(this.fd, var4.getAddress(), var4.getPort()); Net.listen(this.fd, var2 &lt; 1 ? 50 : var2); Object var6 = this.stateLock; synchronized(this.stateLock) { this.localAddress = Net.localAddress(this.fd); } return this; } } } 结论 最后可以发现两个实现方式大同小异，都是调用JDK原生的函数来实现绑定操作，JDK1.7以上的版本调用我们上文提到的ServerSocketChannelImpl的bind方法实现，JDK1.7以下的版本调用ServerSocket的bind方法实现，bind操作会将channel的socket绑定到本地地址，并配置socket以侦听连接。","link":"/2019/08/23/ServerSocketChannel%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%80%9D%E8%80%83/"},{"title":"SpringBoot学习笔记","text":"前言学习spring boot也有一段时间了,今天就把学习的内容整合一下,做一个小的总结。部分内容参照尚硅谷SpringBoot视频教程 一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} 4、编写相关的Controller、Service12345678910@Controllerpublic class HelloController { @ResponseBody @RequestMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World!&quot;; }} 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目123456789101112131415&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication { public static void main(String[] args) { // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); }} @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； ​ ==Spring注解版（谷粒学院）== 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css /images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: {lastName: zhangsan,age: 18} 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: {k1: v1,k2: 12} lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person { private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = &quot;person&quot;)@Validatedpublic class Person { /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value(&quot;${person.last-name}&quot;) private String lastName; //@Value(&quot;#{11*2}&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 123456789101112131415161718192021222324252627282930/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值； * */@PropertySource(value = {&quot;classpath:person.properties&quot;})@Component@ConfigurationProperties(prefix = &quot;person&quot;)//@Validatedpublic class Person { /** * &lt;bean class=&quot;Person&quot;&gt; * &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}&quot;&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value(&quot;${person.last-name}&quot;) private String lastName; //@Value(&quot;#{11*2}&quot;) private Integer age; //@Value(&quot;true&quot;) private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = {&quot;classpath:beans.xml&quot;})导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.atguigu.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类**@Configuration**——&gt;Spring配置文件 2、使用**@Bean**给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig { //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02(){ System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;); return new HelloService(); }} 4、配置文件占位符1、随机数123${random.value}、${random.int}、${random.long}${random.int(10)}、${random.int[1024,65536]} 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三${random.uuid}person.age=${random.int}person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=${person.hello:hello}_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 ```javaSpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104 **==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==**```properties# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) { this.properties = properties; } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; } 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;) //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties { public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； **==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效； 123456789101112131415161718192021222324=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(&quot;Hello World&quot;); }} 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(&quot;rawtypes&quot;)public abstract class LogFactory { static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = &quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() { //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace(&quot;这是trace日志...&quot;); logger.debug(&quot;这是debug日志...&quot;); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info(&quot;这是info日志...&quot;); logger.warn(&quot;这是warn日志...&quot;); logger.error(&quot;这是error日志...&quot;);} 12345678910 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 12345&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ----&gt; [%thread] ---&gt; %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=&quot;!dev&quot;&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 1234xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware { //可以设置和静态资源有关的参数，缓存时间等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(&quot;Default resource handling disabled&quot;); return; } Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) { customizeResourceHandlerRegistration( registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations( &quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(cachePeriod)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); } } //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) { return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); } //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true) public static class FaviconConfiguration { private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) { this.resourceProperties = resourceProperties; } @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() { SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;, faviconRequestHandler())); return mapping; } @Bean public ResourceHttpRequestHandler faviconRequestHandler() { ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; } } ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 123456&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING = Charset.forName(&quot;UTF-8&quot;); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(&quot;text/html&quot;); public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text=&quot;${hello}&quot;&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: ${...}：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. ${session.foo} 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #{…} syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样； 补充：配合 th:object=&quot;${session.user}： &lt;div th:object=&quot;${session.user}&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #{...}：获取国际化内容 Link URL Expressions: @{...}：定义URL； @{/order/process(execId=${execId},execType='FAST')} Fragment Expressions: ~{...}：片段引用表达式 &lt;div th:insert=&quot;~{commons :: main}&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: 'one text' , 'Another one!' ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() { return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件} ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 123初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); }} 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration { private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) { if (!CollectionUtils.isEmpty(configurers)) { this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) { // for (WebMvcConfigurer delegate : this.delegates) { // delegate.addViewControllers(registry); // } } }} ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); }} 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc { 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport { 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class })//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class })public class WebMvcAutoConfiguration { 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;); } //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); } }; return adapter; }} 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public class MessageSourceAutoConfiguration { /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * &quot;org.mypackage&quot;), it will be resolved from the classpath root. */ private String basename = &quot;messages&quot;; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() { ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) { //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); } if (this.encoding != null) { messageSource.setDefaultEncoding(this.encoding.name()); } messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; } 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;&quot;&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@{/webjars/bootstrap/4.0.0/css/bootstrap.css}&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@{/asserts/css/signin.css}&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body class=&quot;text-center&quot;&gt; &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&gt; &lt;img class=&quot;mb-4&quot; th:src=&quot;@{/asserts/img/bootstrap-solid.svg}&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&gt; &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#{login.tip}&quot;&gt;Please sign in&lt;/h1&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#{login.username}&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#{login.username}&quot; required=&quot;&quot; autofocus=&quot;&quot;&gt; &lt;label class=&quot;sr-only&quot; th:text=&quot;#{login.password}&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#{login.password}&quot; required=&quot;&quot;&gt; &lt;div class=&quot;checkbox mb-3&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;/&gt; [[#{login.remember}]] &lt;/label&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#{login.btn}&quot;&gt;Sign in&lt;/button&gt; &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;中文&lt;/a&gt; &lt;a class=&quot;btn btn-sm&quot;&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;) public LocaleResolver localeResolver() { if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) { return new FixedLocaleResolver(this.mvcProperties.getLocale()); } AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; }默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 123456789101112131415161718192021222324252627282930/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver { @Override public Locale resolveLocale(HttpServletRequest request) { String l = request.getParameter(&quot;l&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l)){ String[] split = l.split(&quot;_&quot;); locale = new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) { }} @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); }} 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 123# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style=&quot;color: red&quot; th:text=&quot;${msg}&quot; th:if=&quot;${not #strings.isEmpty(msg)}&quot;&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor { //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object user = request.getSession().getAttribute(&quot;loginUser&quot;); if(user == null){ //未登陆，返回登陆页面 request.setAttribute(&quot;msg&quot;,&quot;没有权限请先登陆&quot;); request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response); return false; }else{ //已登陆，放行请求 return true; } } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { }} 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){ WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;); } //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;) .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;); } }; return adapter; } 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert=&quot;~{footer :: copy}&quot;&gt;&lt;/div&gt;~{templatename::selector}：模板名::选择器~{templatename::fragmentname}:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~{}：行内写法可以加上：[[~{}]];[(~{})]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment=&quot;copy&quot;&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 1234567891011121314151617&lt;nav class=&quot;col-md-2 d-none d-md-block bg-light sidebar&quot; id=&quot;sidebar&quot;&gt; &lt;div class=&quot;sidebar-sticky&quot;&gt; &lt;ul class=&quot;nav flex-column&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link active&quot; th:class=&quot;${activeUri=='main.html'?'nav-link active':'nav-link'}&quot; href=&quot;#&quot; th:href=&quot;@{/main.html}&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-home&quot;&gt; &lt;path d=&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;9 22 9 12 15 12 15 22&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri='emps')&quot;&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action=&quot;@{/emp}&quot; method=&quot;post&quot;&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name=&quot;_method&quot;;值就是我们指定的请求方式--&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; th:if=&quot;${emp!=null}&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:if=&quot;${emp!=null}&quot; th:value=&quot;${emp.id}&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=&quot;lastName&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;${emp!=null}?${emp.lastName}&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=&quot;email&quot; type=&quot;email&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan@atguigu.com&quot; th:value=&quot;${emp!=null}?${emp.email}&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:checked=&quot;${emp!=null}?${emp.gender==1}&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;form-check form-check-inline&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:checked=&quot;${emp!=null}?${emp.gender==0}&quot;&gt; &lt;label class=&quot;form-check-label&quot;&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=&quot;form-control&quot; name=&quot;department.id&quot;&gt; &lt;option th:selected=&quot;${emp!=null}?${dept.id == emp.department.id}&quot; th:value=&quot;${dept.id}&quot; th:each=&quot;dept:${depts}&quot; th:text=&quot;${dept.departmentName}&quot;&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name=&quot;birth&quot; type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;zhangsan&quot; th:value=&quot;${emp!=null}?${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; th:text=&quot;${emp!=null}?'修改':'添加'&quot;&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each=&quot;emp:${emps}&quot;&gt; &lt;td th:text=&quot;${emp.id}&quot;&gt;&lt;/td&gt; &lt;td&gt;[[${emp.lastName}]]&lt;/td&gt; &lt;td th:text=&quot;${emp.email}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.gender}==0?'女':'男'&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${emp.department.departmentName}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@{/emp/}+${emp.id}&quot;&gt;编辑&lt;/a&gt; &lt;button th:attr=&quot;del_uri=@{/emp/}+${emp.id}&quot; class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(&quot;.deleteBtn&quot;).click(function(){ //删除当前员工的 $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;,$(this).attr(&quot;del_uri&quot;)).submit(); return false; });&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(&quot;timestamp&quot;, new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; } ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)public class BasicErrorController extends AbstractErrorController { @RequestMapping(produces = &quot;text/html&quot;)//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(&quot;error&quot;, model) : modelAndView); } @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) { Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); } ​ 3、ErrorPageCustomizer： 12@Value(&quot;${error.path:/error}&quot;)private String path = &quot;/error&quot;; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView; } private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) { //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = &quot;error/&quot; + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) { //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); } //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); } ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) { //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) { ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) { return modelAndView; } } return null;} 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler { @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); return map; }}//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(&quot;javax.servlet.error.status_code&quot;); */ request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500); map.put(&quot;code&quot;,&quot;user.notexist&quot;); map.put(&quot;message&quot;,e.getMessage()); //转发到/error return &quot;forward:/error&quot;; } 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(&quot;company&quot;,&quot;atguigu&quot;); return map; }} 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer(){ return new EmbeddedServletContainerCustomizer() { //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) { container.setPort(8083); } };} 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 1234567//注册三大组件@Beanpublic ServletRegistrationBean myServlet(){ ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;); return registrationBean;} FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter(){ FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;)); return registrationBean;} ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener(){ ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;} SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 123456789101112131415161718@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) { ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) { registration.setMultipartConfig(this.multipartConfig); } return registration;} 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration { @Configuration @ConditionalOnClass({ Servlet.class, Tomcat.class })//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat { @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() { return new TomcatEmbeddedServletContainerFactory(); } } /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty { @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() { return new JettyEmbeddedServletContainerFactory(); } } /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class }) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow { @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() { return new UndertowEmbeddedServletContainerFactory(); } } 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory { //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);} 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) { //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(&quot;tomcat&quot;)); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);} 4）、我们对嵌入式容器的配置修改是怎么生效？ 12ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) { // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); } return bean;}private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) { //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) { customizer.customize(bean); }}private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() { if (this.customizers == null) { // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); } return this.customizers;}ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 5）、嵌入式Servlet容器启动原理；什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try { // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); } catch (BeansException ex) { if (logger.isWarnEnabled()) { logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); } // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; } finally { // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); } }} 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) { //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); }} 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\\springframework\\spring-web\\4.3.14.RELEASE\\spring-web-4.3.14.RELEASE.jar!\\META-INF\\services\\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) { //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) { this.logger.info(&quot;Root context already created (using as parent).&quot;); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); } builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) { application.getSources().add(getClass()); } Assert.state(!application.getSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the &quot; + &quot;configure method or add an @Configuration annotation&quot;); // Ensure error pages are registered if (this.registerErrorPageFilter) { application.getSources().add(ErrorPageFilterConfiguration.class); } //启动Spring应用 return run(application);} 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(/images)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker /images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 123456789101112131415161718192021222324252627282930311、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql &quot;docker-entrypoint.sh&quot; 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat &quot;catalina.sh run&quot; About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql &quot;docker-entrypoint.sh&quot; 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 1234567docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 12org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)static class Generic { @Bean public DataSource dataSource(DataSourceProperties properties) { //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); }} 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源1234567891011121314151617181920212223242526272829303132333435363738394041424344导入druid数据源@Configurationpublic class DruidConfig { @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druid(){ return new DruidDataSource(); } //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet(){ ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问 initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;); bean.setInitParameters(initParams); return bean; } //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter(){ FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; }} 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper { @Select(&quot;select * from department where id=#{id}&quot;) public Department getDeptById(Integer id); @Delete(&quot;delete from department where id=#{id}&quot;) public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;) @Insert(&quot;insert into department(departmentName) values(#{departmentName})&quot;) public int insertDept(Department department); @Update(&quot;update department set departmentName=#{departmentName} where id=#{id}&quot;) public int updateDept(Department department);} 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig { @Bean public ConfigurationCustomizer configurationCustomizer(){ return new ConfigurationCustomizer(){ @Override public void customize(Configuration configuration) { configuration.setMapUnderscoreToCamelCase(true); } }; }} 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = &quot;com.atguigu.springboot.mapper&quot;)@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication { public static void main(String[] args) { SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); }} 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = &quot;tbl_user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User { @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = &quot;last_name&quot;,length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 1234//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; {} 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) { //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) { this.sources.addAll(Arrays.asList(sources)); } //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();} 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try { //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); } //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; } catch (Throwable ex) { handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); }} 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 1234567public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; { @Override public void initialize(ConfigurableApplicationContext applicationContext) { System.out.println(&quot;ApplicationContextInitializer...initialize...&quot;+applicationContext); }} SpringApplicationRunListener 12345678910111213141516171819202122232425262728293031323334public class HelloSpringApplicationRunListener implements SpringApplicationRunListener { //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args){ } @Override public void starting() { System.out.println(&quot;SpringApplicationRunListener...starting...&quot;); } @Override public void environmentPrepared(ConfigurableEnvironment environment) { Object o = environment.getSystemProperties().get(&quot;os.name&quot;); System.out.println(&quot;SpringApplicationRunListener...environmentPrepared..&quot;+o); } @Override public void contextPrepared(ConfigurableApplicationContext context) { System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;); } @Override public void contextLoaded(ConfigurableApplicationContext context) { System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;); } @Override public void finished(ConfigurableApplicationContext context, Throwable exception) { System.out.println(&quot;SpringApplicationRunListener...finished...&quot;); }} 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(&quot;ApplicationRunner...run....&quot;); }} CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(&quot;CommandLineRunner...run...&quot;+ Arrays.asList(args)); }} 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 123456789101112131415161718192021222324252627package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = &quot;atguigu.hello&quot;)public class HelloProperties { private String prefix; private String suffix; public String getPrefix() { return prefix; } public void setPrefix(String prefix) { this.prefix = prefix; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; }} 12345678910111213141516171819package com.atguigu.starter;public class HelloService { HelloProperties helloProperties; public HelloProperties getHelloProperties() { return helloProperties; } public void setHelloProperties(HelloProperties helloProperties) { this.helloProperties = helloProperties; } public String sayHellAtguigu(String name){ return helloProperties.getPrefix()+&quot;-&quot; +name + helloProperties.getSuffix(); }} 1234567891011121314151617181920212223package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration { @Autowired HelloProperties helloProperties; @Bean public HelloService helloService(){ HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; }} 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples","link":"/2018/05/06/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"SpringMVC注解 @ModelAttribute","text":"在 SpringMVC 的 Controller 中使用 @ModelAttribute 时，应用位置包括下面几种： 应用在方法上。 应用在方法的参数上。 应用在方法上，并且方法也使用了@RequestMapping 1.应用在方法上首先说明一下，被 @ModelAttribute 注解的方法会在Controller每个方法执行之前都执行，因此对于一个Controller中包含多个URL的时候，要谨慎使用。 使用 @ModelAttribute 注解无返回值的方法 1234567891011121314@Controller@RequestMapping(&quot;/modelattributeTest&quot;)public class ModelAttributeTestController1 { @ModelAttribute public void myModel(@RequestParam(required = false) String abc, Model model) { model.addAttribute(&quot;attributeName&quot;, abc); } @RequestMapping(value = &quot;/test1&quot;) public String test1() { return &quot;modelattributetest/test1&quot;; }} 这个例子，在请求/modelattributeTest/test1?abc=aaa后，会先执行 myModel方法，然后接着执行test1方法，参数abc的值被放入Model中后，接着被带到 test方法中。 当返回视图 modelattributetest/test1时，Model 会被带到页面上，当然你在使用 @RequestParam的时候可以使用required来指定参数是否是必须的。 如果把 myModel和 test1 合二为一后的方法可以为，这也是我们最常用的方法： 12345@RequestMapping(value = &quot;/test2&quot;)public String test1(@RequestParam(required = false) String abc, Model model) { model.addAttribute(&quot;attributeName&quot;, abc); return &quot;modelattributetest/test1&quot;;} 2）使用 @ModelAttribute 注解带有返回值的方法 12345678910111213141516171819@ModelAttributepublic String myModel(@RequestParam(required = false) String abc) { return abc;}或者@ModelAttributepublic Student myModel(@RequestParam(required = false) String abc) { Student stu = new Student(abc); return stu;}或者@ModelAttributepublic int myModel(@RequestParam(required = false) int number) { return number;} 对于这种情况，返回值对象会被默认放到隐含的 Model中，在 Model中的 key为 “返回值首字母小写”，value 为返回的值。 上面3种情况等同于： 1234model.addAttribute(&quot;string&quot;, abc);model.addAttribute(&quot;int&quot;, number);model.addAttribute(&quot;student&quot;, stu); 如果只能这样，未免太局限了，我们很难接受key 为 string、int、float 等等这样的。 想自定义其实很简单，只需要给@ModelAttribute添加value属性即可，如下： 1234@ModelAttribute(value = &quot;num&quot;) public int myModel(@RequestParam(required = false) int number) { return number;} 这样就相当于 1model.addAttribute(“num”, number); 2.使用@ModelAttribute注解方法的参数1234567891011121314151617181920212223@Controller@RequestMapping(&quot;/modelattributeTest3&quot;)public class ModelAttributeTestController3 { @ModelAttribute(value = &quot;attributeName&quot;) public String myModel(@RequestParam(required = false) String abc) { return abc; } @ModelAttribute public void myModel3(Model model) { model.addAttribute(&quot;name&quot;, &quot;SHANHY&quot;); model.addAttribute(&quot;age&quot;, &quot;28&quot;); } @RequestMapping(value = &quot;/test1&quot;) public String test1(@ModelAttribute(&quot;attributeName&quot;) String str, @ModelAttribute(&quot;name&quot;) String str2, @ModelAttribute(&quot;age&quot;) String str3) { return &quot;modelattributetest/test1&quot;; }} 从代码中可以看出，使用 @ModelAttribute注解的参数，意思是从前面的 Model中提取对应名称的属性。 这里提及一下 @SessionAttributes 的使用： 如果在类上面使用了 @SessionAttributes(“attributeName”) 注解，而本类中恰巧存在attributeName ，则会将 attributeName 放入到 session 作用域。 如果在类上面使用了@SessionAttributes(“attributeName”)注解，SpringMVC 会在执行方法之前，自动从 session 中读取 key 为 attributeName 的值，并注入到 Model中。所以我们在方法的参数中使用@ModelAttribute(“attributeName”)就会正常的从 Model读取这个值，也就相当于获取了 session中的值。 使用了 @SessionAttributes之后，Spring 无法知道什么时候要清掉 @SessionAttributes 存进去的数据，如果要明确告知，也就是在方法中传入 SessionStatus对象参数，并调用 status.setComplete()就可以了。 这两点大家好好尝试下，或者找一下关于 @SessionAttributes更详细的介绍。 3.应用在方法上，并且方法也使用了@RequestMapping如下代码： 1234567891011@Controller@RequestMapping(&quot;/modelattributeTest4&quot;)public class ModelAttributeTestController4 { @RequestMapping(value = &quot;/test1&quot;) @ModelAttribute(&quot;name&quot;) public String test1(@RequestParam(required = false) String name) { return name; }} 这种情况下，返回值 String （或者其他对象），就不再是视图了。还是我们上面将到的放入 Model 中的值，此时对应的页面就是 @RequestMapping的值 test1。","link":"/2018/05/11/SpringMVC%E6%B3%A8%E8%A7%A3%20@ModelAttribute/"},{"title":"ThreadLocal使用学习","text":"ThreadLocal字面上的意思是局部线程变量，每个线程通过ThreadLocal的get和set方法来访问和修改线程自己独有的变量。简单地说，ThreadLocal的作用就是为每一个线程提供了一个独立的变量副本，每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 ThreadLocal的基本使用ThreadLocal是一个泛型类，在创建的时候需要指定变量的类型： 1private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); ThreadLocal提供了set方法来设置变量的值，get方法获取变量的值，remove方法移除变量： 1234567891011public class ThreadLocalTest { private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException { threadLocal.set(&quot;mrbird&quot;); System.out.println(threadLocal.get()); threadLocal.remove(); System.out.println(threadLocal.get()); }} 程序输出如下： 我们也可以给ThreadLocal设置初始值，设置初始值有两种方式： 重写initialValue方法： 1234567891011public class ThreadLocalTest { private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;(){ @Override protected String initialValue() { return &quot;初始值&quot;; } }; public static void main(String[] args) throws InterruptedException { System.out.println(threadLocal.get()); // 初始值 }} 使用ThreadLocal的withInitial方法： 123456public class ThreadLocalTest { private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &quot;初始值&quot;); public static void main(String[] args) throws InterruptedException { System.out.println(threadLocal.get()); // 初始值 }} 值得注意的是remove无法移除初始值： 1234567public class ThreadLocalTest { private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(() -&gt; &quot;初始值&quot;); public static void main(String[] args) throws InterruptedException { threadLocal.remove(); System.out.println(threadLocal.get()); // 初始值 }} 演示多线程间独立在多个线程中使用ThreadLocal： 12345678910111213141516171819202122232425262728293031323334public class ThreadLocalTest2 { private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); private static Random random = new Random(System.currentTimeMillis()); public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread(() -&gt; { threadLocal.set(&quot;thread t1&quot;); try { TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } }, &quot;thread1&quot;); Thread thread2 = new Thread(() -&gt; { threadLocal.set(&quot;thread t2&quot;); try { TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } }, &quot;thread2&quot;); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); }} 程序输出如下： 结果证明了ThreadLocal在每个线程间是相互独立的，threadLocal在thread1、thread2和main线程间都有一份独立拷贝。 ThreadLocal基本原理在ThreadLocal类中有一个静态内部类ThreadLocalMap(概念上类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本。 我们使用Map来代替ThreadLocalMap，创建一个简易的类ThreadLocal实现： 123456789101112131415161718192021222324252627public class MyThreadLocal&lt;T&gt; { private final Map&lt;Thread, T&gt; threadLocalMap = new HashMap&lt;&gt;(); public void set(T t) { synchronized (this) { Thread key = Thread.currentThread(); threadLocalMap.put(key, t); } } public T get() { synchronized (this) { Thread key = Thread.currentThread(); T t = threadLocalMap.get(key); if (t == null) { return initalValue(); } else { return t; } } } public T initalValue() { return null; }} 使用方式和之前的例子一致： 123456789101112131415161718192021222324252627282930313233343536373839public class ThreadLocalTest3 { private static MyThreadLocal&lt;String&gt; threadLocal = new MyThreadLocal&lt;String&gt;() { @Override public String initalValue() { return &quot;initalValue&quot;; } }; private static Random random = new Random(System.currentTimeMillis()); public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread(() -&gt; { threadLocal.set(&quot;thread t1&quot;); try { TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } }, &quot;thread1&quot;); Thread thread2 = new Thread(() -&gt; { threadLocal.set(&quot;thread t2&quot;); try { TimeUnit.MICROSECONDS.sleep(random.nextInt(1000)); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); } catch (InterruptedException e) { e.printStackTrace(); } }, &quot;thread2&quot;); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(Thread.currentThread().getName() + &quot; &quot; + threadLocal.get()); }} 程序输出如下： 使用建议 将ThreadLocal变量指定为private static； 使用完毕后显式地调用remove方法移除。","link":"/2019/07/27/ThreadLocal%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"},{"title":"apollo使用docker-compose部署","text":"apollo使用docker-compose部署 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748version: '2.2'services: apollo: image: idoop/docker-apollo:latest ports: - &quot;8070:8070&quot; - &quot;8180:8180&quot; - &quot;8190:8190&quot; - &quot;8181:8181&quot; - &quot;8191:8191&quot; - &quot;8182:8182&quot; - &quot;8192:8192&quot; - &quot;8183:8183&quot; - &quot;8193:8193&quot; environment: # 开启Portal,默认端口: 8070 PORTAL_DB: jdbc:mysql://10.0.200.34:3306/ApolloPortalDB?characterEncoding=utf8 PORTAL_DB_USER: dev PORTAL_DB_PWD: 123456 DEV_DB: jdbc:mysql://10.0.200.34:3306/ApolloConfigDB_DEV?characterEncoding=utf8 DEV_DB_USER: dev DEV_DB_PWD: 123456 DEV_ADMIN_PORT: 8190 # 与对应环境库的ServerConfig表中的eureka.service.url，IP和端口号保持一致 DEV_CONFIG_PORT: 8180 # 开启fat环境, 默认端口: config 8081, admin 8091 FAT_DB: jdbc:mysql://10.0.200.34:3306/ApolloConfigDB_FAT?characterEncoding=utf8 FAT_DB_USER: dev FAT_DB_PWD: 123456 FAT_ADMIN_PORT: 8191 # 与对应环境库的ServerConfig表中的eureka.service.url，IP和端口号保持一致 FAT_CONFIG_PORT: 8181 # 开启uat环境, 默认端口: config 8082, admin 8092 UAT_DB: jdbc:mysql://10.0.200.34:3306/ApolloConfigDB_UAT?characterEncoding=utf8 UAT_DB_USER: dev UAT_DB_PWD: 123456 UAT_ADMIN_PORT: 8192 # 与对应环境库的ServerConfig表中的eureka.service.url，IP和端口号保持一致 UAT_CONFIG_PORT: 8182 # 开启pro环境, 默认端口: config 8083, admin 8093 PRO_DB: jdbc:mysql://10.0.200.34:3306/ApolloConfigDB_PRO?characterEncoding=utf8 PRO_DB_USER: dev PRO_DB_PWD: 123456 PRO_ADMIN_PORT: 8193 # 与对应环境库的ServerConfig表中的eureka.service.url，IP和端口号保持一致 PRO_CONFIG_PORT: 8183 # 指定注册IP eureka.instance.ip-address: 10.0.8.77","link":"/2019/10/12/apollo%E4%BD%BF%E7%94%A8docker-compose%E9%83%A8%E7%BD%B2/"},{"title":"docker和k8s常见问题记录","text":"docker 和 k8s 相关问题记录 1. k8s 或 docker 中运行 arthas 出现”Unable to get pid of LinuxThreads manager thread”的问题在镜像中添加 init 功能，就是将tini添加到镜像中 12345FROM openjdk:8-jdk-alpineCOPY ./app.jar /opt/RUN apk add --no-cache tiniENTRYPOINT [&quot;/sbin/tini&quot;, &quot;--&quot;]CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/opt/app.jar&quot;] 2. 强制删除 pod1kubectl delete pod app_pod --grace-period=0 --force","link":"/2022/06/15/docker%E5%92%8Ck8s%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"git如何更新fork的项目到原项目的最新版本","text":"在 github 上 fork 了一个项目之后，如何使自己 fork 的项目和原先作者的项目分支保持同步呢，下面我使用 litemall的项目做示范，示范如何使 fork 的项目与原项目分支保持同步。 查看远程的版本库地址 复制 123$ git remote -v origin git@github.com:tcxiaotudou/litemall.git (fetch)origin git@github.com:tcxiaotudou/litemall.git (push) 添加原项目 git 地址到本地版本库 1$ git remote add upstream git@github.com:linlinjava/litemall.git 检查版本库是否添加成功 12345$ git remote -vorigin git@github.com:tcxiaotudou/litemall.git (fetch)origin git@github.com:tcxiaotudou/litemall.git (push)upstream git@github.com:linlinjava/litemall.git (fetch)upstream git@github.com:linlinjava/litemall.git (push) 原项目更新内容同步到本地 12345678910$ git fetch upstream remote: Enumerating objects: 154, done.remote: Counting objects: 100% (154/154), done.remote: Total 346 (delta 153), reused 154 (delta 153), pack-reused 192Receiving objects: 100% (346/346), 53.14 KiB | 100.00 KiB/s, done.Resolving deltas: 100% (186/186), completed with 97 local objects.From github.com:linlinjava/litemall * [new branch] dev -&gt; upstream/dev * [new branch] master -&gt; upstream/master * [new tag] v1.5.0 -&gt; v1.5.0 查看本地分支 1234567$ git branch -a * master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master remotes/upstream/dev remotes/upstream/master 同步更新内容到本地对应分支 1$ git merge upstream/master 提交更新内容到 fork 地址","link":"/2019/08/04/git%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0fork%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%B0%E5%8E%9F%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/"},{"title":"go-zero学习笔记","text":"go-zero 学习过程的相关记录 待完善","link":"/2022/05/16/go-zero%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"nginx安装介绍","text":"nginx的安装介绍。 一、环境调试确认 1.确认系统网络 1ping www.baidu.com 检查能否ping通 2.确认yum可用 1yum list|grep gcc 3.确认关闭iptables规则 123Iptables -L 查看是否有iptables规则Iptables -F 关闭iptables规则Iptables -t nat -L 再次查看是否有iptables规则 4.确认停用selinux 12Getenforce 查看selinux是否开启Setenforce 0 关闭selinux（只是临时关闭 修改/etc/sysconfig/selinux文件可以永久地禁用它。 5.安装基础依赖 gcc和gcc-c++以及相应依赖 1yum -y install gcc gcc-c++ autoconf prce prce-devel make automake 安装vim 12yum -y install wget httpd-tools vimcd /opt;mkdir app download logs work backup 二、下载安装 前往nginx官方下载页面：http://nginx.org/en/download.html 对应版本介绍 Mainline version-开发版 Stable version-稳定版 Legacy version-历史版本 点击页面下方的 Linux packages for stable and mainline versions. 进入对应不同Linux系统的安装介绍 本系统是centos7，所以根据提示： create the file named /etc/yum.repos.d/nginx.repo with the following contents: 查看nginx yum源 1yum install nginx 安装完成，查看安装好的nginx版本：","link":"/2019/07/27/nginx%E5%AE%89%E8%A3%85%E4%BB%8B%E7%BB%8D/"},{"title":"从零开始写JavaWeb框架(一)-从一个简单的Web应用开始","text":"正所谓“工欲善其事，必先利其器”，在正式开始设计并开发我们的轻量级Java Web框架之前，有必要先掌握以下技能：1.使用IDEA搭建并开发Java项目，2.使用Maven自动化构建Java项目，3.使用Git管理项目代码 使用IDEA创建Maven项目创建IDEA项目我们无须单独下载Maven，更不用将其继承到IDEA中，因为IDEA默认已经将其整合了。 在IDEA中创建Maven项目非常简单，只需要按照以下步骤进行即可： 单击 “File” 按钮,选择 “New” ，选择“Project”,弹出 New Project 对话框。 选择Maven选项，单击 ”Next“ 按钮。 输入GroupId，ArtifactId，Version，单击 ”Next“ 按钮。 输入Project name、Project location，单击 “Finish” 按钮。 (Maven相关知识，请自行了解。) 按照以上步骤，IDEA就创建了一个基于Maven的目录结构，如图： 调整Maven配置打开项目中的pom.xml文件，添加配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.fciasth&lt;/groupId&gt; &lt;artifactId&gt;chapter1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 统一源代码的编码方式，否则使用Maven编译源代码时会出现相关警告 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 除了需要统一源代码编码方式外，还需要统一源代码与编译输出的JDK版本，此项目中使用JDK1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 可选配置，当使用Maven打包时，想跳过单元测试，可添加如下插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 至此，一个Maven项目就搭建完毕了，下面我们就要在这个项目中添加有关Java Web的代码。 搭建Web项目框架转为Java Web项目目前，在pom.xml中还没有任何的Maven依赖(dependency)，随后会添加一些Java Web所需的依赖，只不过在添加这些依赖之前，有必要先将这个Maven项目调整为Web项目结构。 只需按照以下三步即可实现： 在main目录下，添加webapp目录。 在webapp下，添加WEB-INF目录。 在WEB-INF目录下，添加web.xml文件。 此时，IDEA给出一个提示。 表示IDEA已经识别出目前我们使用了Web框架(即Servlet框架)，需要进行一些配置才能使用。单击 “Configure” 按钮，会看到一个确认框，单击 “OK” 按钮即可将当前项目变为Web项目。 这里打算使用Servlet3.0框架，所以在web.xml中添加如下代码: 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;web-app xmln=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/web-app&gt; 实际上，使用Servlet3.0框架是可以省略web.xml文件的，因为Servlet无须在web.xml中进行配置，只需通过注解的形式来配置即可，下面绘描述具体的方法。 添加Java Web的Maven依赖由于Web项目是需要打包成war包的，因此必须在pom.xml文件中设置packaging为war(默认为jar)，配置如下 1&lt;packaging&gt;war&lt;/packaging&gt; 接下来就需要添加Java Web所需的Servlet、JSP、JSTL等依赖了，添加如下配置： 1234567891011121314151617181920&lt;dependencies&gt; &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 需要说明的是： Maven依赖的“三坐标”(groupId、artifactId、version)必须提供。 如果某些依赖只需参与编译，而无需打包(例如Tomcat自带了Servlet与JSP所对应的jar包)，可将其scope设置为provided。 如果某些依赖只是运行时需要，但无需参与编译（例如JSTL的jar包），可将其scope设置为runtime。 为了方便阅读，以下是pom.xml的完整代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.fciasth&lt;/groupId&gt; &lt;artifactId&gt;chapter1&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- 统一源代码的编码方式，否则使用Maven编译源代码时会出现相关警告 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- 除了需要统一源代码编码方式外，还需要统一源代码与编译输出的JDK版本，此项目中使用JDK1.8 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 可选配置，当使用Maven打包时，想跳过单元测试，可添加如下插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- Tomcat --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/${project.artifactId}&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 现在一个基于Maven的Java Web项目已经搭建完毕。","link":"/2018/05/07/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99JavaWeb%E6%A1%86%E6%9E%B6-%E4%B8%80/"},{"title":"使用GitLab-CI实现CI&#x2F;CD","text":"之前有用 Jenkins 做过 CI/CD，但是太吃内存了，所以尝试下用 GitLab CI 做持续集成。 GitLab CIGitLab CI 是 GitLab 提供的持续集成服务(从 8.0 版本之后，GitLab CI 已经集成在 GitLab 中了)，只要在你的仓库根目录下创建一个.gitlab-ci.yml 文件，并为该项目指派一个 Runner，当有合并请求或者 Push 操作时，你写在 .gitlab-ci.yml 中的构建脚本就会开始执行，能够自动执行打包，构建，以及部署。 环境说明以下例子是基于： gitlab服务：http://git.mfexcel.com/ GitLab Runner 服务器：10.0.8.237，用于maven打包，构建docker镜像，并推送到docker镜像私服 部署服务器：10.0.8.77，拉取镜像并进行部署 gitlab和gitlab runner的安装就不再赘述了。 请确保上述2台服务器都已安装docker环境，若想使用kubernetes进行部署发布，10.0.8.77上也有使用minikube搭建的kubernetes服务，只需简单修改.gitlab-ci.yml文件即可。 配置maven环境由于我们需要在Gitlab runner服务器10.0.8.237的docker中进行项目的打包即构建，首先要解决的一个问题就是maven的配置问题，因为我们某些第三方包可能需要从nexus私服上进行拉取，所以需要对maven的配置文件进行修改，定制一个用于Gitlab runner进行构建的定制maven镜像，里面同时包含了docker和jdk8的环境，用于之后的打包及镜像构建。 以下为具体的Dockerfile 1234567891011121314FROM maven:3.5.4-jdk-8-alpineMAINTAINER tangchao &lt;tangchao@mfexcel.com&gt;COPY settings.xml /usr/share/maven/ref/RUN apk add --no-cache \\ ca-certificates \\ curl \\ opensslRUN set -x; \\ curl -fSL &quot;https://download.docker.com/linux/static/stable/x86_64/docker-18.03.1-ce.tgz&quot; -o docker.tgz; \\ tar -xzvf docker.tgz; \\ mv docker/* /usr/local/bin/; \\ rmdir docker; \\ rm docker.tgz; \\ docker -v maven的settings配置文件：继承nexus私服以及阿里云仓库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;localRepository&gt;/root/.m2/repository&lt;/localRepository&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;username&gt;hudan&lt;/username&gt; &lt;password&gt;_Cio-v482Hgk_6&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;hudan&lt;/username&gt; &lt;password&gt;_Cio-v482Hgk_6&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;hudan&lt;/username&gt; &lt;password&gt;_Cio-v482Hgk_6&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://192.168.1.98:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://192.168.1.98:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;maven-public&lt;/id&gt; &lt;url&gt;http://192.168.1.98:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;nexus&lt;/activeProfile&gt; &lt;/activeProfiles&gt;&lt;/settings&gt; 使用 docker build -t registry.bizport.cn/ali-maven-docker:3.5.4-jdk-8-alpine . 构建镜像 发布到私服 docker push registry.bizport.cn/ali-maven-docker:3.5.4-jdk-8-alpine 注册Gitlab runner123456789101112131415161718[root@localhost]# gitlab-runner register #1 注册gitlab runnerRuntime platform arch=amd64 os=linux pid=18471 revision=738bbe5a version=13.3.1Running in system-mode. Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://git.mfexcel.com/ #2 连接的gitlab服务地址Please enter the gitlab-ci token for this runner:FzPmqp4A22zf4ZSQR_z6 #3 具体项目的token，可在项目的setting中查看Please enter the gitlab-ci description for this runner:[localhost.localdomain]: xy-docker runner #4 描述，随便写Please enter the gitlab-ci tags for this runner (comma separated):xy-docker runner #5 tag，用于后续 .gitlab-ci的配置中使用Registering runner... succeeded runner=FzPmqp4APlease enter the executor: virtualbox, docker-ssh+machine, docker-ssh, ssh, parallels, shell, docker+machine, kubernetes, custom, docker:docker #6 采用docker方式进行执行构建Please enter the default Docker image (e.g. ruby:2.6):registry.bizport.cn/ali-maven-docker:3.5.4-jdk-8-alpine #7 runner中执行构建时使用的docker镜像，使用上述定制的maven镜像Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 修改config.toml进入/etc/gitlab-runner目录下，找到config.toml，修改刚刚注册runner 12345678910111213141516171819[[runners]] name = &quot;xy-docker runner&quot; url = &quot;http://git.mfexcel.com/&quot; token = &quot;93ea6f5168ad29a2708eaeca189abf&quot; executor = &quot;docker&quot; [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.docker] tls_verify = false image = &quot;registry.bizport.cn/ali-maven-docker:3.5.4-jdk-8-alpine&quot; privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [&quot;/var/run/docker.sock:/var/run/docker.sock&quot;, &quot;/cache&quot;, &quot;/data/apache-maven-repository:/root/.m2/repository&quot;] shm_size = 0 pull_policy = &quot;if-not-present&quot; 添加 maven 库目录的本地映射，这样每次打包时不需要重下依赖包。另外末尾加上 pull_policy = &quot;if-not-present&quot;，这样不会每次都拉镜像。 编写 .gitlab-ci.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253variables: #1 变量 DOCKER_HOST: tcp://10.0.8.237:2375 # 2 gitlab-runner的docker service地址 DOCKER_DRIVER: overlay2 DOCKER_TLS_CERTDIR: '' MAVEN_OPTS: '-Dmaven.repo.local=/root/.m2/repository' IMAGE_NAME: 'registry.bizport.cn/xy-third-syn-system' # 部署命令 RUN_SCRIPT: 'docker run --name xy-third-syn-system -d -p 8099:8080 $IMAGE_NAME'services: #3 在docker中运行docker的一种工具 - docker:dind stages: #4 Pipline的整个流程 - package - build - deploy before_script: - export TAG=$IMAGE_NAME:$CI_COMMIT_SHA - export DEPLOY=$RUN_SCRIPT:$CI_COMMIT_SHApackage: #5 项目打包 stage: package tags: - xy-docker runner script: - mvn clean package -Dmaven.test.skip=true artifacts: paths: - target/*.jar #6 输出上传jar包，用于下一个jobbuild_image: #7 构建镜像 stage: build image: docker:dind tags: - xy-docker runner script: - cp target/*.jar ./ - docker build -f src/main/docker/Dockerfile -t $TAG . - docker push $TAG only: - master deploy: #8 部署 stage: deploy image: ictu/sshpass:latest tags: - xy-docker runner script: # ssh免密登录，IP和密码配在gitlab ci的环境变量里 - sshpass -p &quot;$DEPLOY_HOST_PASSWORD&quot; ssh -o StrictHostKeyChecking=no -tt root@$DEPLOY_HOST_IP $DEPLOY only: - master 效果 pipline执行成功，并在部署服务器上成功部署。","link":"/2019/09/18/%E4%BD%BF%E7%94%A8GitLab-CI%E5%AE%9E%E7%8E%B0CI-CD/"},{"title":"使用Minikube搭建kubernetes","text":"Minikube是一个快速搭建单节点Kubenetes集群的工具，大家可以把它和docker Machine进行类比。 1. 安装Minikube可执行程序MAC 1brew cask install minikub Linux 1curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ Windows 从 https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe 下载重命名成minikube.exe,然后把这个文件的所在目录添加到系统环境变量PATH里。 安装完以后，我们可以通过minikube version 查看系统版本 123➜ ~ minikube versionminikube version: v0.25.0➜ ~ 2.安装kubectl参考https://kubernetes.io/docs/tasks/tools/install-kubectl/ Mac 123$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/darwin/amd64/kubectl$ chmod +x ./kubectl$ sudo mv ./kubectl /usr/local/bin/kubectl Linux 123$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl$ chmod +x ./kubectl$ sudo mv ./kubectl /usr/local/bin/kubectl Windows 下载exe https://storage.googleapis.com/kubernetes-release/release/v1.9.0/bin/windows/amd64/kubectl.exe然后添加到系统PATH环境变量里 安装完以后可以查看版本（我们会看到它有一个报错，因为连不上k8s api server，这个很正常，因为k8s节点还创建呢） 123➜ ~ kubectl versionClient Version: version.Info{Major:&quot;1&quot;, Minor:&quot;9&quot;, GitVersion:&quot;v1.9.3&quot;, GitCommit:&quot;d2835416544f298c919e2ead3be3d0864b52323b&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2018-02-07T12:22:21Z&quot;, GoVersion:&quot;go1.9.2&quot;, Compiler:&quot;gc&quot;, Platform:&quot;darwin/amd64&quot;}The connection to the server localhost:8080 was refused - did you specify the right host or port? 3.安装Virtualbox因为minikube创建K8S虚机是通过Virtualbox来做的（当然还有其它driver，比如KVM，vmware这里就不介绍了） https://www.virtualbox.org/wiki/Downloads 根据自己的操作系统下载安装 3. 运行minikube程序创建k8s通过 minikube starat 去创建k8s环境。如下所示。速度根据个人网速而不同，因为需要下载东西。 12345678910111213141516➜ ~ minikube startStarting local Kubernetes v1.9.0 cluster...Starting VM...Downloading Minikube ISO 142.22 MB / 142.22 MB [============================================] 100.00% 0sGetting VM IP address...Moving files into cluster...Downloading localkube binary 162.41 MB / 162.41 MB [============================================] 100.00% 0s 0 B / 65 B [----------------------------------------------------------] 0.00% 65 B / 65 B [======================================================] 100.00% 0sSetting up certs...Connecting to cluster...Setting up kubeconfig...Starting cluster components...Kubectl is now configured to use the cluster.Loading cached images from config file. 执行结束以后呢，我们可以通过kubectl cluster-info 去连一下k8s api server. 12345➜ ~ kubectl cluster-infoKubernetes master is running at https://192.168.99.100:8443To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.➜ ~ 但是，但是，此时并不代表，整个k8s集群搭建好了，因为k8s里的服务还需要起，比如API server，scheduler，kubelet等等，他们都是以容器的方式在后台启动。 那怎么判断成功了呢？ 我们可以通过minikube ssh进到虚机里，然后看看是否有一些container运行起来了 1234567891011121314151617181920➜ ~ minikube ssh _ _ _ _ ( ) ( ) ___ ___ (_) ___ (_)| |/') _ _ | |_ __/' _ ` _ `\\| |/' _ `\\| || , &lt; ( ) ( )| '_`\\ /'__`\\| ( ) ( ) || || ( ) || || |\\`\\ | (_) || |_) )( ___/(_) (_) (_)(_)(_) (_)(_)(_) (_)`\\___/'(_,__/'`\\____)$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc1aec3464788 gcr.io/k8s-minikube/storage-provisioner &quot;/storage-provisioner&quot; 8 minutes ago Up 8 minutes k8s_storage-provisioner_storage-provisioner_kube-system_05db116c-236a-11e8-985b-08002709a6e3_0f36a4455bc73 fed89e8b4248 &quot;/sidecar --v=2 --...&quot; 8 minutes ago Up 8 minutes k8s_sidecar_kube-dns-54cccfbdf8-c7k5b_kube-system_0649fdef-236a-11e8-985b-08002709a6e3_0e49e279c5717 459944ce8cc4 &quot;/dnsmasq-nanny -v...&quot; 8 minutes ago Up 8 minutes k8s_dnsmasq_kube-dns-54cccfbdf8-c7k5b_kube-system_0649fdef-236a-11e8-985b-08002709a6e3_01ec9842ec31d 512cd7425a73 &quot;/kube-dns --domai...&quot; 8 minutes ago Up 8 minutes k8s_kubedns_kube-dns-54cccfbdf8-c7k5b_kube-system_0649fdef-236a-11e8-985b-08002709a6e3_0805346db62f0 e94d2f21bc0c &quot;/dashboard --inse...&quot; 8 minutes ago Up 8 minutes k8s_kubernetes-dashboard_kubernetes-dashboard-77d8b98585-ghb5p_kube-system_0630dbdf-236a-11e8-985b-08002709a6e3_02c3edf77349e gcr.io/google_containers/pause-amd64:3.0 &quot;/pause&quot; 8 minutes ago Up 8 minutes k8s_POD_kube-dns-54cccfbdf8-c7k5b_kube-system_0649fdef-236a-11e8-985b-08002709a6e3_019313f1076da gcr.io/google_containers/pause-amd64:3.0 &quot;/pause&quot; 8 minutes ago Up 8 minutes k8s_POD_kubernetes-dashboard-77d8b98585-ghb5p_kube-system_0630dbdf-236a-11e8-985b-08002709a6e3_0a340e072f095 gcr.io/google_containers/pause-amd64:3.0 &quot;/pause&quot; 8 minutes ago Up 8 minutes k8s_POD_storage-provisioner_kube-system_05db116c-236a-11e8-985b-08002709a6e3_0dab3d03f880b d166ffa9201a &quot;/opt/kube-addons.sh&quot; 8 minutes ago Up 8 minutes k8s_kube-addon-manager_kube-addon-manager-minikube_kube-system_c4c3188325a93a2d7fb1714e1abf1259_075c8fe4570a1 gcr.io/google_containers/pause-amd64:3.0 &quot;/pause&quot; 8 minutes ago Up 8 minutes k8s_POD_kube-addon-manager-minikube_kube-system_c4c3188325a93a2d7fb1714e1abf1259_0 然后退出来，在本地运行minikube dashboard 会在本地弹出浏览器，就是Kubernetes的dashboard，那基本上恭喜您，安装成功了。 123➜ ~ minikube dashboardOpening kubernetes dashboard in default browser...➜ ~","link":"/2019/09/16/%E4%BD%BF%E7%94%A8Minikube%E6%90%AD%E5%BB%BAkubernetes/"},{"title":"如何理解对扩展开放、修改关闭？","text":"​ 开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。 ​ 这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。 ​ 为了让你更好地理解这个原则，我举一个例子来进一步解释一下。这是一段 API 接口监控告警的代码。 ​ 其中，AlertRule 存储告警规则，可以自由设置。Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel 表示通知的紧急程度，包括 SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道。关于 API 接口监控告警这部分，更加详细的业务需求分析和设计，我们会在后面的设计模式模块再拿出来进一步讲解，这里你只要简单知道这些，就够我们今天用了。 12345678910111213141516171819public class Alert { private AlertRule rule; private Notification notification; public Alert(AlertRule rule, Notification notification) { this.rule = rule; this.notification = notification; } public void check(String api, long requestCount, long errorCount, long durationOfSeconds) { long tps = requestCount / durationOfSeconds; if (tps &gt; rule.getMatchedRule(api).getMaxTps()) { notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;); } if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) { notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;); } }} ​ 上面这段代码非常简单，业务逻辑主要集中在 check() 函数中。当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。 ​ 现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改 check() 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数；第二处是在 check() 函数中添加新的告警逻辑。具体的代码改动如下所示： 12345678910111213141516171819public class Alert { // ...省略AlertRule/Notification属性和构造函数... // 改动一：添加参数timeoutCount public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) { long tps = requestCount / durationOfSeconds; if (tps &gt; rule.getMatchedRule(api).getMaxTps()) { notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;); } if (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) { notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;); } // 改动二：添加接口超时处理逻辑 long timeoutTps = timeoutCount / durationOfSeconds; if (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) { notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;); } }} ​ 这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。 ​ 上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？ ​ 我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分： 第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类； 第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。 具体的代码实现如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Alert { private List&lt;AlertHandler&gt; alertHandlers = new ArrayList&lt;&gt;(); public void addAlertHandler(AlertHandler alertHandler) { this.alertHandlers.add(alertHandler); } public void check(ApiStatInfo apiStatInfo) { for (AlertHandler handler : alertHandlers) { handler.check(apiStatInfo); } }}public class ApiStatInfo {//省略constructor/getter/setter方法 private String api; private long requestCount; private long errorCount; private long durationOfSeconds;}public abstract class AlertHandler { protected AlertRule rule; protected Notification notification; public AlertHandler(AlertRule rule, Notification notification) { this.rule = rule; this.notification = notification; } public abstract void check(ApiStatInfo apiStatInfo);}public class TpsAlertHandler extends AlertHandler { public TpsAlertHandler(AlertRule rule, Notification notification) { super(rule, notification); } @Override public void check(ApiStatInfo apiStatInfo) { long tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds(); if (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) { notification.notify(NotificationEmergencyLevel.URGENCY, &quot;...&quot;); } }}public class ErrorAlertHandler extends AlertHandler { public ErrorAlertHandler(AlertRule rule, Notification notification){ super(rule, notification); } @Override public void check(ApiStatInfo apiStatInfo) { if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) { notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;); } }} 上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？具体的使用代码我也写在这里了。 其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。 12345678910111213141516171819202122232425262728293031public class ApplicationContext { private AlertRule alertRule; private Notification notification; private Alert alert; public void initializeBeans() { alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码 notification = new Notification(/*.省略参数.*/); //省略一些初始化代码 alert = new Alert(); alert.addAlertHandler(new TpsAlertHandler(alertRule, notification)); alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification)); } public Alert getAlert() { return alert; } // 饿汉式单例 private static final ApplicationContext instance = new ApplicationContext(); private ApplicationContext() { instance.initializeBeans(); } public static ApplicationContext getInstance() { return instance; }}public class Demo { public static void main(String[] args) { ApiStatInfo apiStatInfo = new ApiStatInfo(); // ...省略设置apiStatInfo数据值的代码 ApplicationContext.getInstance().getAlert().check(apiStatInfo); }} 现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有下面四处。 第一处改动是：在 ApiStatInfo 类中添加新的属性 timeoutCount。 第二处改动是：添加新的 TimeoutAlertHander 类。 第三处改动是：在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler。 第四处改动是：在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。改动之后的代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738public class Alert { // 代码未改动... }public class ApiStatInfo {//省略constructor/getter/setter方法 private String api; private long requestCount; private long errorCount; private long durationOfSeconds; private long timeoutCount; // 改动一：添加新字段}public abstract class AlertHandler { //代码未改动... }public class TpsAlertHandler extends AlertHandler {//代码未改动...}public class ErrorAlertHandler extends AlertHandler {//代码未改动...}// 改动二：添加新的handlerpublic class TimeoutAlertHandler extends AlertHandler {//省略代码...}public class ApplicationContext { private AlertRule alertRule; private Notification notification; private Alert alert; public void initializeBeans() { alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码 notification = new Notification(/*.省略参数.*/); //省略一些初始化代码 alert = new Alert(); alert.addAlertHandler(new TpsAlertHandler(alertRule, notification)); alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification)); // 改动三：注册handler alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification)); } //...省略其他未改动代码...}public class Demo { public static void main(String[] args) { ApiStatInfo apiStatInfo = new ApiStatInfo(); // ...省略apiStatInfo的set字段代码 apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值 ApplicationContext.getInstance().getAlert().check(apiStatInfo);} 重构之后的代码更加灵活和易扩展。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。","link":"/2019/10/14/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE%E3%80%81%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD%EF%BC%9F/"},{"title":"投资记录","text":"投资记录… 主策略 主要资金用来构建自己的资产组合，如下图： 雪球精选：https://danjuanfunds.com/activity/fund-home/001?channel=XQWX1112 剩余资金用来做短线ETF(基于RSI指标，14日30临界值) 增量资金用来做网格或买入债券 如何择时买入： 等指数回到 5 年（1250日）均线的位置(下图的❶❷❸❹等位置)，做一次动态平衡，抛一点债券买一点股票。 若继续下跌，则开始定投加仓，直至涨回到5年均线位置。 如果进一步下跌，触及 5 年均线-15%的位置，再做一次动态平衡。 卖出： 90 日 RSI 大多数时间在43 点(红色水平线)和 57 点(淡绿色水平线)之前盘整，泡沫大牛市会冲到 70 点(深绿色水平线)之上。所以可以考虑在 90 日 RSI 触及 57 点和 70 点的时候进行一次动态平衡，抛股买债。 当然，一旦出现冲上90 日 RSI的 70 点高位，出现如此疯狂的牛市，还应该考虑的是不是要调整整体的股债比例，比如像我这样 70%股票+30%债券的股债组合，是不是要反向变成 30%股票+70%债券了。 RSI用法 相关链接 [ “五年之锚”还能怎么用](“五年之锚”还能怎么用 (qq.com)) 有知有行全市场温度 美國十年期國債債券孳息率","link":"/2023/10/24/%E6%8A%95%E8%B5%84%E8%AE%B0%E5%BD%95/"},{"title":"接入disconf使用docker部署jar包启动无法指定配置参数","text":"接入disconf使用docker部署jar包启动无法指定配置参数，官方其实已经指出解决方案 这对于直接用java -jar 来启动该springboot项目是OK的，但是构建到docker里就不行了，dockerfile是提前写好的，里面已经写死了启动命令了，后期我们只能去修改docker的启动端口什么的，无法再传入上面的java -Ddisconf.XXX参数了（或者会的话告诉我一下，就不用下面的步骤了）。那么怎么在不同的环境下动态设置disconf.env参数呢，在使用同一个docker镜像的情况下。 查看源码，我们可以知道：执行顺序是这样的，先读取disconf.properties里的所有属性，然后赋值，譬如将配置文件里的disconf.env定义的rd取出来，赋给变量env。然后再去读取系统环境变量，System.getProperty(name)，如果也有值，就覆盖从properties里读取的值，这样就是官方说的从java命令行输入参数就能直接动态覆盖配置文件。 根据这个特性我们就能来定制env了，对的，就是使用环境变量。我们只需要在项目启动时加载disconf.env的环境变量，就能动态指定env了。在docker下，环境变量是很容易设置的。 解决方案如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.xy.onlineteam.HSEI.config;import com.baidu.disconf.client.DisconfMgrBean;import com.baidu.disconf.client.DisconfMgrBeanSecond;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;/** * @ClassName DisConfig * @Description TODO * @Author tangchao@mfexcel.com * @Date 2020/8/24 15:43 * @Version 1.0 */@Configurationpublic class DisConfig implements EnvironmentAware { @Bean(destroyMethod = &quot;destroy&quot;) public DisconfMgrBean getDisconfMgrBean() { DisconfMgrBean disconfMgrBean = new DisconfMgrBean(); disconfMgrBean.setScanPackage(&quot;com.xy.onlineteam.HSEI&quot;); return disconfMgrBean; } @Bean(destroyMethod = &quot;destroy&quot;, initMethod = &quot;init&quot;) public DisconfMgrBeanSecond getDisconfMgrBean2() { return new DisconfMgrBeanSecond(); } @Override public void setEnvironment(Environment environment) { String env = environment.getProperty(&quot;disconf.conf_server_host&quot;); if(env != null) { System.setProperty(&quot;disconf.conf_server_host&quot;, env); } }} docker run 启动时，-e 指定disconf环境参数","link":"/2019/10/04/%E6%8E%A5%E5%85%A5disconf%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2jar%E5%8C%85%E5%90%AF%E5%8A%A8%E6%97%A0%E6%B3%95%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"},{"title":"面试相关","text":"面试相关","link":"/2023/10/25/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"k8s","slug":"k8s","link":"/tags/k8s/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"投资","slug":"投资","link":"/tags/%E6%8A%95%E8%B5%84/"}],"categories":[{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/categories/ElasticSearch/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Go","slug":"Go","link":"/categories/Go/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"K8s","slug":"K8s","link":"/categories/K8s/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"}]}